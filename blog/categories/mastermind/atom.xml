<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mastermind | Striving for Adequacy]]></title>
  <link href="http://calvached.github.io/blog/categories/mastermind/atom.xml" rel="self"/>
  <link href="http://calvached.github.io/"/>
  <updated>2014-06-10T09:36:04-05:00</updated>
  <id>http://calvached.github.io/</id>
  <author>
    <name><![CDATA[Diana Calvache]]></name>
    <email><![CDATA[hello@dianathegeek.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby, Pass by What?]]></title>
    <link href="http://calvached.github.io/blog/2014/06/02/ruby-pass-by-what/"/>
    <updated>2014-06-02T10:12:24-05:00</updated>
    <id>http://calvached.github.io/blog/2014/06/02/ruby-pass-by-what</id>
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/3gQVzL0.gif" alt="david-tennant-confused" /></p>

<p>There are two questions that have been bugging me lately. The first, <em>Why do I have to clone a guess in Mastermind?</em> and the second came after I did some research, <em>What is pass by reference vs. pass by value?</em></p>

<p>Let&rsquo;s start with the first question.</p>

<!-- more -->


<p>To simplify what I was experiencing here&rsquo;s an example:<br/>
``` ruby Black magic code going on here
class ExampleClass
  def example_method</p>

<pre><code>var = 'woohooo'

p var.object_id # Object Id: 70131019948560

x = SomeClass.new
x.some_method(var)
p x.return_var # returns 'woohooo'

y = AnotherClass.new
y.another_method(var)

p x.return_var # returns 'boohooo', whyyy??
</code></pre>

<p>  end
end</p>

<p>class SomeClass
  def some_method(var)</p>

<pre><code>@new_var = var
</code></pre>

<p>  end</p>

<p>  def return_var</p>

<pre><code>p @new_var.object_id # Object Id: 70131019948560

@new_var
</code></pre>

<p>  end
end</p>

<p>class AnotherClass
  def another_method(var)</p>

<pre><code>var[0] = 'b'
p var.object_id # Object Id: 70131019948560

var
</code></pre>

<p>  end
end</p>

<p>j = ExampleClass.new
j.example_method
```
So what exactly is going on here? In my ExampleClass I&rsquo;m passing some_method a variable with the value &ldquo;woohooo&rdquo; and I expect it to return the same value (since I&rsquo;m not making any changes), BUT when I call another_method and pass it the same variable it changes the value that&rsquo;s being returned by return_var. What is this sorcery?!<br/>
<img src="http://i.imgur.com/PezBytD.gif" alt="Witchcraft black magic code" /></p>

<p>I could easily solve the problem by using the .clone method which creates a copy of the variable and be on my way, but that&rsquo;s not how I roll. This leads us to my second question, <em>What is pass by reference vs. pass by value?</em></p>

<p>After consulting with my long-time friend, Google, what seems to be going on is that each time I&rsquo;m passing a variable to a method it&rsquo;s not making a copy of the variable, but rather making a copy of the reference to the same object in memory (which is why the Object Ids are all the same). I was absolutely baffled since I had assumed that Ruby makes object copies each time a variable is passed to a method (Oh and by the way this example doesn&rsquo;t work with Fixnum objects, apparently they have &ldquo;immediate value&rdquo; which means that the actual object is passed and not a reference).</p>

<p>In this example we see something a little bit different.<br/>
``` ruby Slightly less bewildering code
def change(x)
  x.object_id # Object Id: 70266982826660
  x = &lsquo;10&rsquo;
  x.object_id # Object Id: 70266982862600</p>

<p>  x
end</p>

<p>y = &lsquo;3&rsquo;
y.object_id # Object Id: 70266982826660</p>

<p>change(y) # returns &lsquo;10&rsquo;
y # returns &lsquo;3&rsquo;
```
I&rsquo;m passing a variable to the change method and while inside the method I&rsquo;m assigning it a different value. This method does exactly what I expect it to, it returns a different value, but it leaves the original variable the same. Why? Because the reference is changed (we can see this by looking at the difference in Object Ids) and the return value is actually a completely different object.</p>

<p>In my first example the referenced object value was changed, but in the second example the reference itself was changed. Like I said&hellip;witchcraft!</p>

<p>Here&rsquo;s a really great simple analogy that I found.<br/>
<blockquote><p>Say I want to share a web page with you.</p></p><p><p>If I tell you the URL, I&rsquo;m passing by reference. You can use that URL to see the same web page I can see. If that page is changed, we both see the changes. If you delete the URL, all you&rsquo;re doing is destroying your reference to that page &ndash; you&rsquo;re not deleting the actual page itself.</p></p><p><p>If I print out the page and give you the printout, I&rsquo;m passing by value. Your page is a disconnected copy of the original. You won&rsquo;t see any subsequent changes, and any changes that you make (e.g. scribbling on your printout) will not show up on the original page. If you destroy the printout, you have actually destroyed your copy of the object &ndash; but the original web page remains intact.</p><footer><strong>Dylan Beattie <a href="http://stackoverflow.com/a/430958">http://stackoverflow.com/a/430958</a> StackOverflow</strong></footer></blockquote></p>

<p>TL;DR Ruby is Pass by Value because a copy of a reference to an object is passed and not the object itself.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[So, You Want to Be a Mastermind?]]></title>
    <link href="http://calvached.github.io/blog/2014/05/30/so-you-want-to-be-a-mastermind/"/>
    <updated>2014-05-30T11:10:29-05:00</updated>
    <id>http://calvached.github.io/blog/2014/05/30/so-you-want-to-be-a-mastermind</id>
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/ANjI6Vi.png" alt="Mastermind" /></p>

<p>For the last few days I&rsquo;ve been writing tests for a game I&rsquo;m working on called <strong>Mastermind</strong>.</p>

<!-- more -->


<p>The rules are simple. There are two players, the Codemaker (AI) and the Codebreaker (human player). The Codemaker is in charge of creating a four letter pattern from a given set of six letters (A-F). The Codebreaker&rsquo;s job is to correctly guess the pattern in the least number of tries (max of 10 tries). After each attempt the Codemaker gives the Codebreaker feedback by indicating how many letters are correct and in the right position by returning a &lsquo;o&rsquo; for each exact match. Letters that are in the wrong position, but exist in the pattern will return an &lsquo;x&rsquo;.<br/>
For instance if the Codemaker&rsquo;s pattern were &ldquo;AFDE&rdquo; and the Codebreaker&rsquo;s guess were &ldquo;ADFE&rdquo; then the returned feedback will look like this: &ldquo;ooxx&rdquo;.</p>

<p>There were two particular pieces of logic that were giving me trouble. The first had to do with the logic behind finding letters that matched the CM&rsquo;s pattern in the correct position.</p>

<p>``` ruby Find matching letters with the correct position
def letter_with_position_match(user_guess)</p>

<pre><code>@indexes = []
counter = []
user_guess.each_with_index do |cb_letter, cb_i|
        if @unsolved_pattern.include?(cb_letter)
            @unsolved_pattern.each_with_index do |cm_letter, cm_i|
              if cb_letter == cm_letter &amp;&amp; cb_i == cm_i
                @indexes &lt;&lt; cm_i
                counter &lt;&lt; cb_letter 
              end
            end
        end
    end

counter.length
</code></pre>

<p>end
```</p>

<p>I came up with a working algorithm by iterating through the CB&rsquo;s pattern and the CM&rsquo;s pattern, taking each individual letter and index from both, and comparing them. If a letter matched then it&rsquo;s index also had to match. At this point I also decided that I needed to hold on to those indexes so that I would know which letters haven&rsquo;t been matched yet.</p>

<p>Although this code works, it definitely doesn&rsquo;t look very readable and it&rsquo;s plagued with repetition. After sitting down with my mentor, Kelly, we decided to take this a different route and begin with TDD (test driven development) instead. With TDD you first write a test, then write the code to pass the test, and repeat. With practice, TDD serves as a guideline in writing clean and simple code.</p>

<p>We started with simple tests like the ones below.</p>

<p>``` ruby codemaker_spec.rb <a href="https://github.com/calvached/mastermind/blob/master/spec/codemaker_spec.rb">https://github.com/calvached/mastermind/blob/master/spec/codemaker_spec.rb</a> Source Article
describe CodeMaker do</p>

<p>  context &ldquo;position matches&rdquo; do</p>

<pre><code>it "returns 4 if the guess matches pattern exactly" do
  codemaker = CodeMaker.new
  codemaker.unsolved_pattern = ["A", "B", "E", "E"]
  expect(codemaker.feedback(["A", "B", "E", "E"])).to eq(["o", "o", "o", "o"])
end

it "returns 0 if the guess has no letters in the same position as the pattern" do
  codemaker = CodeMaker.new
  codemaker.unsolved_pattern = ["A", "B", "C", "D"]
  expect(codemaker.feedback(["F", "F", "F", "F"])).to eq([])
end

it "returns 3 if the guess has 3 letters in the same position as the pattern" do
  codemaker = CodeMaker.new
  codemaker.unsolved_pattern = ["A", "B", "C", "D"]
  expect(codemaker.feedback(["A", "B", "C", "F"])).to eq(["o", "o", "o"])
end
</code></pre>

<p>  end
end
```
Each test only tests one small feature. Every new test we wrote became more specific and addressed the next feature that we needed to cover. Eventually our tests looked like <a href="https://github.com/calvached/mastermind/blob/master/spec/codemaker_spec.rb">this</a>.</p>

<p>As a result we were able to improve my icky icky method from before into something more decent and readable.</p>

<p>``` ruby codemaker.rb <a href="https://github.com/calvached/mastermind/blob/master/lib/codemaker.rb">https://github.com/calvached/mastermind/blob/master/lib/codemaker.rb</a> Source Article
def exact_feedback</p>

<pre><code>    @matches_indexes = []
    results = []

    @guess.each_with_index do |letter, i|
        if @unsolved_pattern[i] == letter
            results &lt;&lt; 'o' 
            @matches_indexes &lt;&lt; i
        end
    end

    results
end
</code></pre>

<p>```</p>

<p>The second bump in the road I ran into was in iterating through the CB&rsquo;s guess and checking whether they guessed any letters correctly even if in the wrong position. The problem here was that I didn&rsquo;t want to iterate through letters that were already matched in my first method (which is why I saved the indexes from the first matches).</p>

<p>``` ruby codemaker.rb <a href="https://github.com/calvached/mastermind/blob/master/lib/codemaker.rb">https://github.com/calvached/mastermind/blob/master/lib/codemaker.rb</a> Source Article
def get_unmatched(sequence, matched_placeholder)</p>

<pre><code>new_sequence = sequence.clone

@matches_indexes.each do |position|
    new_sequence[position] = matched_placeholder
end

new_sequence
</code></pre>

<p>  end
```</p>

<p>To find the unmatched letters I first had to clone (or duplicate) the pattern so that my original pattern will stay intact. Using the new cloned pattern I replaced all the letters at every index location with a symbol then returned the new cloned pattern.</p>

<p>``` ruby codemaker.rb <a href="https://github.com/calvached/mastermind/blob/master/lib/codemaker.rb">https://github.com/calvached/mastermind/blob/master/lib/codemaker.rb</a> Source Article
def letter_feedback</p>

<pre><code>results = []

get_unmatched(@guess, '+').uniq.each do |letter|
  results &lt;&lt; 'x' if get_unmatched(@unsolved_pattern, '-').include?(letter)
end

    results
</code></pre>

<p>end
```</p>

<p>Skipping the already matched letters was only part of the problem, the second part involved duplicate letters in the CM&rsquo;s and the CB&rsquo;s patterns. I created an algorithm where I thought I solved the problem by using the .uniq method, but what I didn&rsquo;t take into account was that the CB&rsquo;s pattern also had to be modified for letters that were already matched.<br/>
For instance if the CM&rsquo;s pattern was &ldquo;EDEC&rdquo; and the CB guessed &ldquo;EDDD&rdquo;. I would expect for the feedback to look something like this &ldquo;oo&rdquo;, but instead I was getting &ldquo;oox&rdquo;. By using the get_unmatched method on not only the CM&rsquo;s pattern, but also the CB&rsquo;s pattern I was able to fix the error I was getting.</p>

<p>Mastermind has actually been really fun to build, tear down, build again and refactor! Implementing tests has made it so much easier to work on error cases.</p>
]]></content>
  </entry>
  
</feed>
